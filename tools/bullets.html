<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
</head>

<body style="margin:0;overflow:hidden">
    <script src="../tmlib.js/build/tmlib.js"></script>
    <script src="../three.js/build/three.js"></script>
    <script src="../three.js/examples/js/controls/OrbitControls.js"></script>
    <script>
    var count = 16;
    var obj;

    window.onload = function() {

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(0, 0, 10);

        scene.add(new THREE.DirectionalLight(0xffffff, 1.0));
        scene.add(new THREE.AmbientLight(0x888888));

        var axisHelper = new THREE.AxisHelper(100);
        scene.add(axisHelper);

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);

        var h = Array.range(0, count * count).map(function(){ return Math.randf(0.001, 0.020) });
        var r = Array.range(0, count * count).map(function(){ return Math.randf(2, 50) });
        var o = Array.range(0, count * count).map(function(){ return Math.randf(0, Math.PI * 2) });

        var frame = 0;
        var render = function() {
            requestAnimationFrame(render);
            controls.update();

            if (obj) {
                obj.material.uniforms.time.value += 0.001;

                var uv = obj.geometry.getAttribute("uv");
                uv.needsUpdate = true;
                var uposition = obj.geometry.getAttribute("uposition");
                uposition.needsUpdate = true;
                var urotation = obj.geometry.getAttribute("urotation");
                urotation.needsUpdate = true;
                var ubright = obj.geometry.getAttribute("ubright");
                ubright.needsUpdate = true;

                for (var index = 0; index < count * count; index++) {
                    var bx = Math.cos(o[index] + (frame - 1) * h[index]) * r[index];
                    var by = Math.sin(o[index] + (frame - 1) * h[index]) * r[index];
                    var x = Math.cos(o[index] + frame * h[index]) * r[index];
                    var y = Math.sin(o[index] + frame * h[index]) * r[index];
                    var d = Math.atan2(y - by, x - bx);

                    var u = frame % 8;
                    var v = frame % 2;
                    var umin = u * 1 / 8;
                    var umax = (u + 1) * 1 / 8;
                    var vmin = v * 1 / 8;
                    var vmax = (v + 1) * 1 / 8;

                    uv.array[(index * 4 + 0) * 2 + 0] = umin;
                    uv.array[(index * 4 + 0) * 2 + 1] = 1 - vmin;
                    uv.array[(index * 4 + 1) * 2 + 0] = umax;
                    uv.array[(index * 4 + 1) * 2 + 1] = 1 - vmin;
                    uv.array[(index * 4 + 2) * 2 + 0] = umax;
                    uv.array[(index * 4 + 2) * 2 + 1] = 1 - vmax;
                    uv.array[(index * 4 + 3) * 2 + 0] = umin;
                    uv.array[(index * 4 + 3) * 2 + 1] = 1 - vmax;

                    uposition.array[(index * 4 + 0) * 3 + 0] = x;
                    uposition.array[(index * 4 + 1) * 3 + 0] = x;
                    uposition.array[(index * 4 + 2) * 3 + 0] = x;
                    uposition.array[(index * 4 + 3) * 3 + 0] = x;
                    uposition.array[(index * 4 + 0) * 3 + 1] = y;
                    uposition.array[(index * 4 + 1) * 3 + 1] = y;
                    uposition.array[(index * 4 + 2) * 3 + 1] = y;
                    uposition.array[(index * 4 + 3) * 3 + 1] = y;

                    urotation.array[index * 4 + 0] = d;
                    urotation.array[index * 4 + 1] = d;
                    urotation.array[index * 4 + 2] = d;
                    urotation.array[index * 4 + 3] = d;

                    var bright = Math.sin(frame * 0.3) + 2.0;
                    ubright.array[index * 4 + 0] = bright;
                    ubright.array[index * 4 + 1] = bright;
                    ubright.array[index * 4 + 2] = bright;
                    ubright.array[index * 4 + 3] = bright;
                }
            }

            renderer.render(scene, camera);
            frame += 1;
        };
        render();

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        main(scene);
    };

    var main = function(scene) {
        var geometry = new THREE.BufferGeometry();
        
        var vertices = [];
        var indices = [];
        var uvs = [];
        var upos = [];
        var urot = [];
        var ubright = [];
        var uvisible = [];
        for (var x = 0; x < count; x++) {
            for (var y = 0; y < count; y++) {
                var i = y * count + x;

                vertices.push([x * 1.1 + 0.05, y * 1.1 + 0.05, 0]);
                vertices.push([x * 1.1 + 1.05, y * 1.1 + 0.05, 0]);
                vertices.push([x * 1.1 + 1.05, y * 1.1 + 1.05, 0]);
                vertices.push([x * 1.1 + 0.05, y * 1.1 + 1.05, 0]);

                indices.push([i * 4 + 0, i * 4 + 1, i * 4 + 2]);
                indices.push([i * 4 + 0, i * 4 + 2, i * 4 + 3]);

                var u = 3;
                var v = 0;
                var umin = u * 1 / 8;
                var umax = (u + 1) * 1 / 8;
                var vmin = v * 1 / 8;
                var vmax = (v + 1) * 1 / 8;

                uvs.push([umin, 1 - vmin]);
                uvs.push([umax, 1 - vmin]);
                uvs.push([umax, 1 - vmax]);
                uvs.push([umin, 1 - vmax]);

                upos.push([0, 0, 0]);
                upos.push([0, 0, 0]);
                upos.push([0, 0, 0]);
                upos.push([0, 0, 0]);

                urot.push(0);
                urot.push(0);
                urot.push(0);
                urot.push(0);

                ubright.push(1);
                ubright.push(1);
                ubright.push(1);
                ubright.push(1);

                uvisible.push(1);
                uvisible.push(1);
                uvisible.push(1);
                uvisible.push(1);
            }
        }

        geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(vertices.flatten()), 3));
        geometry.addAttribute("index", new THREE.BufferAttribute(new Uint32Array(indices.flatten()), 3));
        geometry.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(uvs.flatten()), 2));
        geometry.addAttribute("uposition", new THREE.BufferAttribute(new Float32Array(upos.flatten()), 3));
        geometry.addAttribute("urotation", new THREE.BufferAttribute(new Float32Array(urot), 1));
        geometry.addAttribute("ubright", new THREE.BufferAttribute(new Float32Array(ubright), 1));
        geometry.addAttribute("uvisible", new THREE.BufferAttribute(new Float32Array(uvisible), 1));

        obj = new THREE.Mesh(geometry, new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.DoubleSide,
            transparent: true,
            depthTest: false,
            attributes: {
                "uposition": {
                    type: "v3",
                    value: null,
                },
                "urotation": {
                    type: "f",
                    value: null,
                },
                "ubright": {
                    type: "f",
                    value: null,
                },
                "uvisible": {
                    type: "f",
                    value: null,
                },
            },
            uniforms: {
                "time": {
                    type: "f",
                    value: 0,
                },
                "texture": {
                    type: "t",
                    value: THREE.ImageUtils.loadTexture("../images/bullets.png"),
                },
            },
        }));
        scene.add(obj);
    };

    var vertexShader = [

        "attribute vec3 uposition;",
        "attribute float urotation;",
        "attribute float ubright;",
        "attribute float uvisible;",

        "uniform float time;",

        "varying vec2 vUv;",
        "varying float vBright;",
        "varying float vVisible;",

        "void main() {",

        "    float idx = floor(position.y / 1.1) * 80.0 + floor(position.x / 1.1);",
        "    vec3 leftBottom = vec3(floor(position.x / 1.1) * 1.1, floor(position.y / 1.1) * 1.1, 0.0);",
        "    vec3 mid = leftBottom + vec3(0.5, 0.5, 0.0);",
        "    vec3 pos = position - mid;",

        "    mat4 m = ",
        "    mat4(",
        "        1.0, 0.0, 0.0, 0.0,",
        "        0.0, 1.0, 0.0, 0.0,",
        "        0.0, 0.0, 1.0, 0.0,",
        "        uposition.x, uposition.y, uposition.z, 1.0",
        "    )",
        "    *",
        "    mat4(",
        "        cos(urotation), sin(urotation), 0.0, 0.0,",
        "       -sin(urotation), cos(urotation), 0.0, 0.0,",
        "        0.0, 0.0, 1.0, 0.0,",
        "        0.0, 0.0, 0.0, 1.0",
        "    );",
        "    vec4 mvPosition = viewMatrix * m * vec4(pos, 1.0);",
        "    vec4 p = projectionMatrix * mvPosition;",

        "    vUv = uv;",
        "    vBright = ubright;",
        "    vVisible = uvisible;",

        "    gl_Position = p;",

        "}",

    ].join("\n");

    var fragmentShader = [
        "uniform sampler2D texture;",

        "varying vec2 vUv;",
        "varying float vBright;",
        "varying float vVisible;",

        "void main() {",
        "    if (vVisible == 0.0) {",
        "        discard;",
        "    }",

        "    vec4 color = texture2D(texture, vUv);",
        "    gl_FragColor = vec4(color.rgb * vBright, color.a);",

        "}",

    ].join("\n");
    </script>
</body>

</html>
