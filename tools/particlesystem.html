<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
</head>

<body style="margin:0;overflow:hidden">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
    <script src="../tmlib.js/build/tmlib.js"></script>
    <script src="../three.js/build/three.js"></script>
    <script src="../three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="../scripts/shader/easing.js"></script>
    <script>
    var vertexShader = [

        "attribute float startTime;",
        "attribute float endTime;",

        "attribute vec3  positionTo;",
        "uniform   int   positionEasing;",

        "attribute vec3  sizeInfo;",
        "uniform   int   sizeEasing;",

        "attribute vec3  texRotInfo;",
        "uniform   int   texRotEasing;",

        "attribute vec3  redInfo;",
        "uniform   int   redEasing;",

        "attribute vec3  greenInfo;",
        "uniform   int   greenEasing;",

        "attribute vec3  blueInfo;",
        "uniform   int   blueEasing;",

        "attribute vec3  alphaInfo;",
        "uniform   int   alphaEasing;",

        "uniform float now;",
        "uniform float timeScale;",
        "uniform float scale;",

        "varying mat3 vTexRot;",
        "varying float vVisible;",
        "varying vec4 vColor;",

        EasingFunctions,

        "void main() {",
        "    float sizeFrom      = sizeInfo[0];",
        "    float sizeTo        = sizeInfo[1];",
        "    float sizeDuration  = sizeInfo[2];",
        "",
        "    float texRotFrom    = texRotInfo[0];",
        "    float texRotTo      = texRotInfo[1];",
        "    float texRotDuration= texRotInfo[2];",
        "",
        "    float redFrom       = redInfo[0];",
        "    float redTo         = redInfo[1];",
        "    float redDuration   = redInfo[2];",
        "",
        "    float greenFrom     = greenInfo[0];",
        "    float greenTo       = greenInfo[1];",
        "    float greenDuration = greenInfo[2];",
        "",
        "    float blueFrom      = blueInfo[0];",
        "    float blueTo        = blueInfo[1];",
        "    float blueDuration  = blueInfo[2];",
        "",
        "    float alphaFrom     = alphaInfo[0];",
        "    float alphaTo       = alphaInfo[1];",
        "    float alphaDuration = alphaInfo[2];",
        "",
        "    float time = (now / timeScale - startTime) / (endTime - startTime);",
        "    if (time < 0.0) {",
        "        vVisible = 0.0;",
        "        return;",
        "    } else {",
        "        vVisible = 1.0;",
        "    }",
        "",
        "    float sizeTime  = (now / timeScale - startTime) / sizeDuration;",
        "    float texRotTime= (now / timeScale - startTime) / texRotDuration;",
        "    float redTime   = (now / timeScale - startTime) / redDuration;",
        "    float greenTime = (now / timeScale - startTime) / greenDuration;",
        "    float blueTime  = (now / timeScale - startTime) / blueDuration;",
        "    float alphaTime = (now / timeScale - startTime) / alphaDuration;",
        "",
        "    float texRot = texRotFrom + (texRotTo - texRotFrom) * ease(texRotEasing, texRotTime);",
        "    vTexRot = mat3(",
        "        1.0, 0.0, 0.0,",
        "        0.0, 1.0, 0.0,",
        "        0.5, 0.5, 1.0",
        "    ) * mat3(",
        "        cos(texRot), sin(texRot), 0.0,",
        "       -sin(texRot), cos(texRot), 0.0,",
        "        0.0, 0.0, 1.0",
        "    ) * mat3(",
        "        1.0, 0.0, 0.0,",
        "        0.0, 1.0, 0.0,",
        "       -0.5,-0.5, 1.0",
        "    );",
        "",
        "    vColor = vec4(",
        "        redFrom   + (redTo   - redFrom)   * ease(redEasing,   redTime),",
        "        greenFrom + (greenTo - greenFrom) * ease(greenEasing, greenTime),",
        "        blueFrom  + (blueTo  - blueFrom)  * ease(blueEasing,  blueTime),",
        "        alphaFrom + (alphaTo - alphaFrom) * ease(alphaEasing, alphaTime)",
        "    );",
        "",
        "    vec4 mvPosition = modelViewMatrix * vec4( position + (positionTo - position) * ease(positionEasing, time), 1.0 );",
        "    float s = sizeFrom + (sizeTo - sizeFrom) * ease(sizeEasing, sizeTime);",
        "    gl_PointSize = s * ( 300.0 / length( mvPosition.xyz ) ) * scale;",
        "    gl_Position = projectionMatrix * mvPosition;",
        "}",
    ].join("\n");

    var fragmentShader = [

        "uniform sampler2D texture;",

        "varying mat3 vTexRot;",
        "varying float vVisible;",
        "varying vec4 vColor;",

        "void main() {",
        "    if (vVisible == 0.0) {",
        "        discard;",
        "    }",
        "    gl_FragColor = texture2D( texture, (vTexRot * vec3(gl_PointCoord, 1.0)).xy ) * vColor;",
        "}",

    ].join("\n");

    tm.main(function() {

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.set(10, 10, 10);

        scene.add(new THREE.DirectionalLight(0xffffff, 1.0));
        scene.add(new THREE.AmbientLight(0x888888));

        var axisHelper = new THREE.AxisHelper(100);
        scene.add(axisHelper);

        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);

        var frame = 0;
        var render = function() {
            requestAnimationFrame(render);

            update(frame);
            controls.update();
            renderer.render(scene, camera);

            frame += 1;
        };

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        window.addEventListener('mouseup', function() {
            restart(param);
        });

        var param = {}.$extend(DEFAULT_PARAM);
        param.texture = (function() {
            var radius = 1024;
            var canvas = document.createElement("canvas");
            canvas.width = radius;
            canvas.height = radius;
            var ctx = canvas.getContext("2d");
            var g = ctx.createRadialGradient(radius * 0.5, radius * 0.5, 0, radius * 0.5, radius * 0.5, radius * 0.5);
            g.addColorStop(0.00, "hsla(  0,  80%, 100%, 1.0)");
            g.addColorStop(0.20, "hsla(  0,  80%, 100%, 1.0)");
            g.addColorStop(1.00, "hsla(  0,  80%, 100%, 0.0)");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, radius, radius);

            var texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        })();

        var s = function() {
            restart(param)
        };
        var easings = {
            LINEAR: 0,
            EASE_IN_QUAD: 1,
            EASE_OUT_QUAD: 2,
            EASE_INOUT_QUAD: 3,
            CUBIC_IN: 4,
            CUBIC_OUT: 5,
            CUBIC_IN_OUT: 6,
            QUARTIC_IN: 7,
            QUARTIC_OUT: 8,
            QUARTIC_IN_OUT: 9,
            QINTIC_IN: 10,
            QINTIC_OUT: 11,
            QINTIC_IN_OUT: 12,
            SINE_IN: 13,
            SINE_OUT: 14,
            SINE_IN_OUT: 15,
            EXPONENTIAL_IN: 16,
            EXPONENTIAL_OUT: 17,
            EXPONENTIAL_IN_OUT: 18,
            CIRCULAR_IN: 19,
            CIRCULAR_OUT: 20,
            CIRCULAR_IN_OUT: 21,
            ELASTIC_IN: 22,
            ELASTIC_OUT: 23,
            ELASTIC_IN_OUT: 24,
            BACK_IN: 25,
            BACK_OUT: 26,
            BACK_IN_OUT: 27,
            BOUNCE_OUT: 28,
            BOUNCE_IN: 29,
            BOUNCE_IN_OUT: 30,
        };
        var gui = new dat.GUI();
        gui.remember(param);
        gui.add(param, "count", 0.0, 5000.0).onFinishChange(s);
        gui.add(param, "scale", 0.0, 5.0).onFinishChange(s);
        gui.add(param, "timeScale", 0.0, 300.0).onFinishChange(s);
        gui.add(param, "startRandom", 0.0, 3.0).onFinishChange(s);
        gui.add(param, "lifeTime", 0.0, 10.0).onFinishChange(s);
        gui.add(param, "lifeTimeRandom", 0.0, 10.0).onFinishChange(s);
        gui.add(param, "distance", 0.0, 20.0).onFinishChange(s);
        gui.add(param, "distanceRandom", 0.0, 10.0).onFinishChange(s);
        var sizeFolder = gui.addFolder("size");
        sizeFolder.add(param, "sizeFrom", 0.0, 10.0).onFinishChange(s);
        sizeFolder.add(param, "sizeTo", 0.0, 10.0).onFinishChange(s);
        sizeFolder.add(param, "sizeDuration", 0.0, 5.0).onFinishChange(s);
        sizeFolder.open();
        var texRotFolder = gui.addFolder("texRot");
        texRotFolder.add(param, "texRotFrom", 0.0, 10.0).onFinishChange(s);
        texRotFolder.add(param, "texRotTo", 0.0, 10.0).onFinishChange(s);
        texRotFolder.add(param, "texRotDuration", 0.0, 5.0).onFinishChange(s);
        var redFolder = gui.addFolder("red");
        redFolder.add(param, "redFrom", 0.0, 10.0).onFinishChange(s);
        redFolder.add(param, "redTo", 0.0, 10.0).onFinishChange(s);
        redFolder.add(param, "redDuration", 0.0, 5.0).onFinishChange(s);
        redFolder.open();
        var greenFolder = gui.addFolder("green");
        greenFolder.add(param, "greenFrom", 0.0, 10.0).onFinishChange(s);
        greenFolder.add(param, "greenTo", 0.0, 10.0).onFinishChange(s);
        greenFolder.add(param, "greenDuration", 0.0, 5.0).onFinishChange(s);
        greenFolder.open();
        var blueFolder = gui.addFolder("blue");
        blueFolder.add(param, "blueFrom", 0.0, 10.0).onFinishChange(s);
        blueFolder.add(param, "blueTo", 0.0, 10.0).onFinishChange(s);
        blueFolder.add(param, "blueDuration", 0.0, 5.0).onFinishChange(s);
        blueFolder.open();
        var alphaFolder = gui.addFolder("alpha");
        alphaFolder.add(param, "alphaFrom", 0.0, 10.0).onFinishChange(s);
        alphaFolder.add(param, "alphaTo", 0.0, 10.0).onFinishChange(s);
        alphaFolder.add(param, "alphaDuration", 0.0, 5.0).onFinishChange(s);
        alphaFolder.open();
        var easingFolder = gui.addFolder("easing");
        easingFolder.add(param, "positionEasing", easings).onFinishChange(s);
        easingFolder.add(param, "sizeEasing", easings).onFinishChange(s);
        easingFolder.add(param, "texRotEasing", easings).onFinishChange(s);
        easingFolder.add(param, "redEasing", easings).onFinishChange(s);
        easingFolder.add(param, "greenEasing", easings).onFinishChange(s);
        easingFolder.add(param, "blueEasing", easings).onFinishChange(s);
        easingFolder.add(param, "alphaEasing", easings).onFinishChange(s);
        easingFolder.open();

        restart(param);
        render();

    });

    var scene;
    var mesh;

    var DEFAULT_PARAM = {
        position: function() {
            return {
                from: new THREE.Vector3(0, 0, 0),
                to: new THREE.Vector3(Math.random() * 1 - 0.5, Math.random() * 1 - 0.5, Math.random() * 1 - 0.5),
            };
        },
        count: 1000,
        scale: 1.0,
        timeScale: 60,
        texture: null,
        lifeTime: 1.0,
        lifeTimeRandom: 0.0,
        startRandom: 0,
        distance: 5,
        distanceRandom: 0,
        sizeFrom: 1.0,
        sizeTo: 1.0,
        sizeDuration: 1.0,
        texRotFrom: 1.0,
        texRotTo: 1.0,
        texRotDuration: 1.0,
        redFrom: 1.0,
        redTo: 1.0,
        redDuration: 1.0,
        greenFrom: 1.0,
        greenTo: 1.0,
        greenDuration: 1.0,
        blueFrom: 1.0,
        blueTo: 1.0,
        blueDuration: 1.0,
        alphaFrom: 1.0,
        alphaTo: 0.0,
        alphaDuration: 1.0,
        positionEasing: 0,
        sizeEasing: 0,
        texRotEasing: 0,
        redEasing: 0,
        greenEasing: 0,
        blueEasing: 0,
        alphaEasing: 0,
    };

    var restart = function(param) {
        if (mesh) {
            scene.remove(mesh);
        }

        param = {}.$extend(DEFAULT_PARAM, param);

        var count = param.count;

        var geometry = new THREE.BufferGeometry();

        var startTime = new Float32Array(count);
        var endTime = new Float32Array(count);
        var positionFrom = new Float32Array(count * 3);
        var positionTo = new Float32Array(count * 3);
        var positionEasing = new Int32Array(count);
        var sizeInfo = new Float32Array(count * 3);
        var texRotInfo = new Float32Array(count * 3);
        var redInfo = new Float32Array(count * 3);
        var greenInfo = new Float32Array(count * 3);
        var blueInfo = new Float32Array(count * 3);
        var alphaInfo = new Float32Array(count * 3);
        var texRot = new Float32Array(count);

        var vec = new THREE.Vector3();
        for (var i = 0; i < count; i++) {

            var pos = param.position();

            startTime[i] = Math.random() * param.startRandom;
            endTime[i] = startTime[i] + param.lifeTime * (1.0 + Math.random() * param.lifeTimeRandom);

            positionFrom[i * 3 + 0] = pos.from.x;
            positionFrom[i * 3 + 1] = pos.from.y;
            positionFrom[i * 3 + 2] = pos.from.z;

            pos.to.setLength(param.distance * (1.0 + Math.random() * param.distanceRandom));

            positionTo[i * 3 + 0] = pos.to.x;
            positionTo[i * 3 + 1] = pos.to.y;
            positionTo[i * 3 + 2] = pos.to.z;

            sizeInfo[i * 3 + 0] = param.sizeFrom; // from
            sizeInfo[i * 3 + 1] = param.sizeTo; // to
            sizeInfo[i * 3 + 2] = param.sizeDuration; // duration

            texRotInfo[i * 3 + 0] = param.texRotFrom; // from
            texRotInfo[i * 3 + 1] = param.texRotTo; // to
            texRotInfo[i * 3 + 2] = param.texRotDuration; // duration

            redInfo[i * 3 + 0] = param.redFrom; // from
            redInfo[i * 3 + 1] = param.redTo; // to
            redInfo[i * 3 + 2] = param.redDuration; // duration

            greenInfo[i * 3 + 0] = param.greenFrom; // from
            greenInfo[i * 3 + 1] = param.greenTo; // to
            greenInfo[i * 3 + 2] = param.greenDuration; // duration

            blueInfo[i * 3 + 0] = param.blueFrom; // from
            blueInfo[i * 3 + 1] = param.blueTo; // to
            blueInfo[i * 3 + 2] = param.blueDuration; // duration

            alphaInfo[i * 3 + 0] = param.alphaFrom; // from
            alphaInfo[i * 3 + 1] = param.alphaTo; // to
            alphaInfo[i * 3 + 2] = param.alphaDuration; // duration
        }

        geometry.addAttribute('startTime', new THREE.BufferAttribute(startTime, 1));
        geometry.addAttribute('endTime', new THREE.BufferAttribute(endTime, 1));
        geometry.addAttribute('position', new THREE.BufferAttribute(positionFrom, 3));
        geometry.addAttribute('positionTo', new THREE.BufferAttribute(positionTo, 3));
        geometry.addAttribute('sizeInfo', new THREE.BufferAttribute(sizeInfo, 3));
        geometry.addAttribute('texRotInfo', new THREE.BufferAttribute(texRotInfo, 3));
        geometry.addAttribute('redInfo', new THREE.BufferAttribute(redInfo, 3));
        geometry.addAttribute('greenInfo', new THREE.BufferAttribute(greenInfo, 3));
        geometry.addAttribute('blueInfo', new THREE.BufferAttribute(blueInfo, 3));
        geometry.addAttribute('alphaInfo', new THREE.BufferAttribute(alphaInfo, 3));

        var material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            attributes: {
                startTime: {
                    type: 'f',
                    value: null
                },
                endTime: {
                    type: 'f',
                    value: null
                },
                positionTo: {
                    type: 'v3',
                    value: null
                },
                sizeInfo: {
                    type: 'v3',
                    value: null
                },
                texRotInfo: {
                    type: 'v3',
                    value: null
                },
                redInfo: {
                    type: 'v3',
                    value: null
                },
                greenInfo: {
                    type: 'v3',
                    value: null
                },
                blueInfo: {
                    type: 'v3',
                    value: null
                },
                alphaInfo: {
                    type: 'v3',
                    value: null
                },
            },
            uniforms: {
                now: {
                    type: "f",
                    value: 0.0
                },
                scale: {
                    type: 'f',
                    value: param.scale
                },
                timeScale: {
                    type: "f",
                    value: param.timeScale
                },
                texture: {
                    type: "t",
                    value: param.texture
                },
                positionEasing: {
                    type: 'i',
                    value: param.positionEasing
                },
                sizeEasing: {
                    type: 'i',
                    value: param.sizeEasing
                },
                texRotEasing: {
                    type: 'i',
                    value: param.texRotEasing
                },
                redEasing: {
                    type: 'i',
                    value: param.redEasing
                },
                greenEasing: {
                    type: 'i',
                    value: param.greenEasing
                },
                blueEasing: {
                    type: 'i',
                    value: param.blueEasing
                },
                alphaEasing: {
                    type: 'i',
                    value: param.alphaEasing
                },
            },
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        mesh = new THREE.PointCloud(geometry, material);
        scene.add(mesh);
    };

    var update = function(frame) {
        mesh.material.uniforms.now.value += 1;
    };
    </script>
</body>

</html>
